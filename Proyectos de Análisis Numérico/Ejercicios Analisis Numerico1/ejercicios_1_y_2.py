# -*- coding: utf-8 -*-
"""Ejercicios 1 y 2 Tarea 2. DSCE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C9OhuekfwZd-l-q_2UBRg2ZOgIo8Fa95

# **Ejercicio 1**
"""

#INCISO a)
import numpy as np
import pandas as pd

# Ponemos la funcion que queremos resover
def f(x):
    return x**3 + 4*x**2 - 10

#definimos la funcion del Método, en este caso el de la falsa posisción
#como argumentos le ponemos la tolerancia permitida y las iteraciones= 50
def falsa_posicion(tol=0.00001, max_iter=50):
    #definimos los extremos del intervalo [a, b], que se nos da, en este caso [0,1]
    a = 0
    b = 1

    #tenemos una funcion polinómica, lo que implica que tenemos una función continua
    #por eso ponemos el texto que dice que se asume y asi se inicie el metodo
    print(f"Tomemos la función como continua en [{a}, {b}].")

    #imprimimos los valores de f(a) y f(b)
    print(f"f(a) = f({a}) = {f(a)}")
    print(f"f(b) = f({b}) = {f(b)}")

    #vemos si hay cambio de signo
    if f(a) * f(b) > 0:
        #si existe cambio de signo sigue el metodo, sino aparece este mensaje:
        print("No se puede encontrar una raíz en el intervalo porque no hay cambio de signo")
        return None

    #La tabla que usaremos tendra los siguientes elementos:
    datos = {"Iteración": [], "Aproximación": [], "f(x)": [], "Error": []}

    #empezamos a iterar a traves del for, poniendo como maximo las 50 iteraciones
    for i in range(1, max_iter + 1):
        #con la formula encontramos las x's
        x = a - ((b-a)/(f(b)-f(a)))*f(a)
        #al error le sacamos valor abs
        error = abs(f(x))

        #tomamos los valores de cada iteracion y los vamos poniendo en la tabla
        datos["Iteración"].append(i)
        datos["Aproximación"].append(x)
        datos["f(x)"].append(f(x))
        datos["Error"].append(error)

        #Cuando se cumpla la tolerancia dejamos de iterar
        if error < tol:
            print(f"logramos enocntrar la raiz con la tolerancia permitida en la iteración: {i}.")
            break

        #aqui vamos reasignando el nuevo intervalo
        if f(a) * f(x) < 0:
            b = x
        else:
            a = x

    #la tabla con los resultados:
    tabla = pd.DataFrame(datos)
    display(tabla)

    #cuanto nos dio la x que cumpla la tolerancia
    return x

#ahora si ejecutamos
falsa_posicion()

#INCISO d)
import numpy as np
import pandas as pd

#ponemos la funcion que queremos resover
def f(x):
    return x**3 + 4*x**2 - 10

#definimos la funcion del Método, en este caso el de la secante
#como argumentos le ponemos la tolerancia permitida y las iteraciones= 50
def secante(tol=0.00001, max_iter=50):
#definimos los extremos del intervalo [a, b], que se nos da, en este caso [0,1]
    x0 = 0
    x1 = 1
#tenemos una funcion polinómica, lo que implica que tenemos una función continua
#por eso ponemos el texto que dice que se asume y asi se inicie el metodo
    print(f"Tomemos la función como continua en [{x0}, {x1}].")
    #imprimimos los valores de f(0) y f(1)
    print(f"f(x0) = f({x0}) = {f(x0)}")
    print(f"f(x1) = f({x1}) = {f(x1)}")

    #La tabla que usaremos tendra los siguientes elementos:
    datos = {"Iteración": [], "Aproximación": [], "f(x)": [], "Error": []}
    #empezamos a iterar a traves del for, poniendo como maximo las 50 iteraciones
    for i in range(1, max_iter + 1):
        #aqui queremos evitar dividir entre 0
        if f(x1) - f(x0) == 0:
            print("Tenemos una indeterminación (division entre cero)")
            break

        #aplicamos la fromaula del metodo
        x2 = x1 - f(x1)*(x1 - x0)/(f(x1) - f(x0))
        error = abs(x2 - x1)

        #tomamos los valores de cada iteracion y los vamos poniendo en la tabla
        datos["Iteración"].append(i)
        datos["Aproximación"].append(x2)
        datos["f(x)"].append(f(x2))
        datos["Error"].append(error)

        #Cuando se cumpla la tolerancia dejamos de iterar
        if error < tol:
            print(f"Tolerancia alcanzada en la iteración {i}.")
            break

        #reasignamos los valores en cada iteracion
        x0 = x1
        x1 = x2

   #la tabla con los resultados:
    tabla = pd.DataFrame(datos)
    display(tabla)

    #cuanto nos dio la x que cumpla la tolerancia
    return x2

#ahora si ejecutamos
secante()

"""# **Ejercicio 2**"""

import numpy as np
#definimos la funcion para analizar
def analizar_matriz(A):

    #para ver que es cuadrada, veremos si tiene la misma cantidad de renglones
    #que de filas, para eso usamos .shape
    if A.shape[0] == A.shape[1]:
        print("1. A es cuadrada")

        #para ver que es ivertible veremos si el det(A)!=0, para eso usamos
        #np.linalg.det(A), que calcula el determinanate
        det = np.linalg.det(A)
        if det != 0:
            print(f"2. A es invertible (det = {det})")
        else:
            print(f"2. A no es invertible (det = {det})")

        #cuando una matriz es simetrica esa matriz es igual a su transpuesta
        #para eso comparamos ambas matrices con np.array_equal
        matriz_trans = A.T
        if np.array_equal(A, matriz_trans):
            print("3. A es simétrica")

            #para que una matriz sea definida positiva necesitamos que sea simétrica
            #por eso el if de la definida positiva esta dentro del de simetrica
            #ahora los eingvalores los calculamos con np.linalg.eigvals
            eigenvalores = np.linalg.eigvals(A)
            #aqui necesitamos que todos los eingevalores sean mayores a cero
            #para eso los metemos en un ciclo for que valide que sean mayores a cero
            if all(i > 0 for i in eigenvalores):
                print(f"4. A es definida positiva (Eigenvalores: {eigenvalores})")
            else:
                print(f"4. A no es definida positiva (Eigenvalores: {eigenvalores})")
        else:
            print("3. A no es simétrica")
            print("4. No se puede comprobar si es definida positiva (requiere simetría)")
    else:
        #si una matriz no es cuadrada no podemos verificar las otras propiedades
        print("1. A no es cuadrada")
        print("   No se pueden verificar las otras propiedades")

# siguiendo el ejemplo tenemos:
if __name__ == "__main__":
    matriz = np.array([[2, 0, -1],
                       [0, 2, 1],
                       [-1, 1, 2]])

    analizar_matriz(matriz)